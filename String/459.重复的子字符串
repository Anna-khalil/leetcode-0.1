//在掐头去尾后的双倍字符串里还能再看到原字符串，就说明原串必然是周期串。
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        string t = s + s;
        t.erase(t.begin()); // 掐头去尾
        t.erase(t.end() - 1); //注意这里是end() - 1 
        if (t.find(s) != std::string::npos) return true; // 如果找到，返回第一次出现的下标
// 如果未找到，返回 std::string::npos（一个特殊静态常量，通常等于 size_t(-1)，数值很大）。
        return false;
    }
};

//不采取以下解法
//kmp len = s.size()   k = next[len - 1] + 1   // 最长前缀后缀长度
//若 k > 0 且 len % (len - k) == 0，则字符串可整除成若干段，每段长度为 len - k，即为周期。
class Solution {
public:
    void getNext(int* next, const string& s){
            int j = -1;
            next[0] = j;
            for(int i = 1; i < s.size(); i++){
                while(j >= 0 && s[i] != s[j+1] ){
                    j = next[j];
                }
                if( s[i] == s[j+1]){
                    j++;
                }
                next[i] = j;
            }
        }
    bool repeatedSubstringPattern(string s) {
        if( s.size() == 0 ) { return false;}

        int next[s.size()];
        getNext(next,s);
        int len = s.size();
        int k = next[len - 1] + 1;//最长前后缀长度
        if( k > 0 && len % (len - k) == 0) return true;
        else return false; 
    }
};