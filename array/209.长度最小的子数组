//暴力 TLE
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int res = INT32_MAX;//最短子序列长度
        int sum = 0;//子序列的总和
        for(int i=0; i < nums.size(); i++)
        {
            sum = 0;
            for(int j = i; j < nums.size(); j++)
            {
                sum += nums[j];
                if(sum >= target)
                {
                    res = res < j - i + 1 ? res : j - i + 1;//三目 条件 ？ 成立 ：否定
                    break;
                }
            }
        }

        return res == INT32_MAX ? 0 : res;

    }
};

//acwing 滑动窗口 n队列长度 k滑动窗口长度 找序列中窗口内的最小值
//这里子序列是连续的
   int hh = 0, tt = -1;//队列头 队列尾  | tt     hh | q[]存下标
    for (int i = 0; i < n; i ++ )
    {
        if (hh <= tt && i - k + 1 > q[hh]) hh ++ ;//队头弹出 窗口长度已满

        while (hh <= tt && a[q[tt]] >= a[i]) tt -- ;//维序(与当前元素对比)
        q[ ++ tt] = i;//队尾插入 满足条件时插入

        if (i >= k - 1) printf("%d ", a[q[hh]]);//窗口填满 可以输出
    }


//最终输出 满足条件的 最小子序列（连续）的长度
//不用维序
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        const int INF = 0x3f3f3f3f;
        int res = INF;
        int l = 0;//左边界
        int sum = 0;
        
        for(int r = 0; r < nums.size(); r++ ) {//插入
            sum += nums[r];
            while( sum >= target) {
                res = min(res, r - l + 1);
                sum -= nums[l++];//弹出
            }
        }
        if( res == INF ) return 0;
        else return res;
    }
};